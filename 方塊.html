<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>3D 第一人稱：最終整合版 (含詳細註解)</title>
    <style>
        /* 基礎樣式：讓畫布填滿全螢幕並隱藏捲軸 */
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        
        /* 初始提示畫面的黑框樣式 */
        #instructions {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; background: rgba(0, 0, 0, 0.8); padding: 20px;
            text-align: center; cursor: pointer; z-index: 100; border-radius: 10px;
        }
        
        /* 畫面中央的準星 */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 10px; height: 10px;
            border: 2px solid white; border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; z-index: 50;
        }
    </style>
</head>
<body>

    <div id="instructions">
        <h1>☞點擊開始☜</h1>
        <p>| WASD 移動 | 空白鍵 跳躍 | Shift 慢走 |</p><p><B><br>٭∗*走過的地方會留下青色粒子</B></p>
    </div>
    <div id="crosshair"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 1. 場景與相機基礎設定 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // 設定背景為天空藍
        scene.fog = new THREE.Fog(0x87ceeb, 0, 100); // 加入霧氣效果，增加空間感

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true }); // 開啟反鋸齒
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 2. 第一人稱控制器設定 ---
        const controls = new PointerLockControls(camera, document.body);
        const instructions = document.getElementById('instructions');

        // 點擊 UI 觸發滑鼠鎖定 (進入遊戲模式)
        instructions.addEventListener('click', () => controls.lock());
        
        // 當滑鼠被鎖定時，隱藏 UI；解鎖時重新顯示
        controls.addEventListener('lock', () => instructions.style.display = 'none');
        controls.addEventListener('unlock', () => instructions.style.display = 'block');

        // --- 3. 物理與高度變數設定 ---
        const STAND_HEIGHT = 1.6;  // 常規站立高度
        const SNEAK_HEIGHT = 0.8;  // 蹲下時的高度
        const PLAYER_RADIUS = 0.5; // 玩家的碰撞半徑（身體厚度）

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        let isSneaking = false;    // 紀錄是否按住 Shift
        let currentHeight = STAND_HEIGHT; // 動態紀錄目前的視角高度

        const velocity = new THREE.Vector3(); // 玩家當前的移動速度向量
        const objects = [];                   // 用於存放場景中所有的障礙物（方塊）

        // --- 4. 粒子系統設定 ---
        const particles = []; // 存放畫面上存在的粒子
        const particleGeometry = new THREE.SphereGeometry(0.05, 8, 8); // 小球體粒子
        const particleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true });

        // --- 5. 鍵盤事件監聽 ---
        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) { velocity.y += 20; canJump = false; } break; // 給予向上的速度
                case 'ShiftLeft': isSneaking = true; break; // 開啟蹲下狀態
            }
        });
        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isSneaking = false; break; // 結束蹲下狀態
            }
        });

        // --- 6. 創建場景物件 (環境光、地板、隨機方塊) ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.8)); // 加入環境光，讓場景亮起來

        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200), 
            new THREE.MeshPhongMaterial({ color: 0x333333 })
        );
        floor.rotation.x = -Math.PI / 2; // 將平面轉為水平
        scene.add(floor);

        // 隨機生成 20 個方塊
        for (let i = 0; i < 20; i++) {
            const h = Math.random() * 3 + 1; // 隨機高度 1~4
            const box = new THREE.Mesh(
                new THREE.BoxGeometry(4, h, 4), 
                new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff })
            );
            box.position.set(Math.random() * 60 - 30, h / 2, Math.random() * 60 - 30);
            scene.add(box);
            objects.push(box); // 加入碰撞偵測清單
        }

        // --- 7. 碰撞偵測函式 ---
        // 邏輯：檢查目標位置是否與任何方塊重疊，並回傳腳下平面的高度
        function checkCollision(targetPos) {
            let collision = false;
            let currentFloorY = 0; // 預設地面高度為 0
            for (const obj of objects) {
                const boxMinX = obj.position.x - 2, boxMaxX = obj.position.x + 2;
                const boxMinZ = obj.position.z - 2, boxMaxZ = obj.position.z + 2;
                const boxTop = obj.geometry.parameters.height;

                // 判斷玩家在 X-Z 平面上是否進入了方塊範圍
                const isInsideX = targetPos.x + PLAYER_RADIUS > boxMinX && targetPos.x - PLAYER_RADIUS < boxMaxX;
                const isInsideZ = targetPos.z + PLAYER_RADIUS > boxMinZ && targetPos.z - PLAYER_RADIUS < boxMaxZ;

                if (isInsideX && isInsideZ) {
                    // 如果玩家腳底高度高於方塊，則判定為「站在方塊上」
                    if (targetPos.y >= boxTop + 0.1) {
                        currentFloorY = Math.max(currentFloorY, boxTop);
                    } else {
                        // 否則判定為「撞牆」
                        collision = true;
                    }
                }
            }
            return { collision, floorY: currentFloorY };
        }

        // --- 8. 粒子生成函式 ---
        function createParticle(pos, floorY) {
            const p = new THREE.Mesh(particleGeometry, particleMaterial.clone());
            p.position.set(pos.x, floorY + 0.05, pos.z); // 將粒子放在腳底下的平面
            p.userData.life = 2.0; // 粒子壽命為 2 秒
            scene.add(p);
            particles.push(p);
        }

        // --- 9. 遊戲主動畫迴圈 (每一幀執行一次) ---
        let prevTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            if (controls.isLocked) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000; // 計算距離上一幀經過了多少秒

                // 物理計算：模擬阻力 (讓速度隨時間變慢)
                velocity.x -= velocity.x * 20.0 * delta;
                velocity.z -= velocity.z * 20.0 * delta;
                velocity.y -= 9.8 * 5.0 * delta; // 模擬重力加速度

                // 處理移動速度 (蹲下時變慢)
                const currentSpeed = isSneaking ? 100.0 : 250.0;
                const moveDir = new THREE.Vector3();
                moveDir.z = Number(moveForward) - Number(moveBackward);
                moveDir.x = Number(moveRight) - Number(moveLeft);
                moveDir.normalize();

                if (moveForward || moveBackward) velocity.z -= moveDir.z * currentSpeed * delta;
                if (moveLeft || moveRight) velocity.x -= moveDir.x * currentSpeed * delta;

                const playerObj = controls.getObject();
                const oldPos = playerObj.position.clone();
                
                // --- A. 水平位移與撞牆處理 ---
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                let wallInfo = checkCollision(playerObj.position);
                if (wallInfo.collision) {
                    playerObj.position.x = oldPos.x; // 撞牆後強制退回原位
                    playerObj.position.z = oldPos.z;
                }

                // --- B. 蹲下動畫平滑過渡 ---
                const targetH = isSneaking ? SNEAK_HEIGHT : STAND_HEIGHT;
                currentHeight = THREE.MathUtils.lerp(currentHeight, targetH, delta * 10); // 平滑變更視角高度

                // --- C. Shift 邊緣保護邏輯 ---
                // 如果在蹲下且在地面上，預判下一步。如果腳下會懸空，則取消該次移動
                if (isSneaking && canJump) {
                    let edgeCheck = checkCollision(playerObj.position);
                    if (edgeCheck.floorY < (oldPos.y - currentHeight - 0.1)) {
                        playerObj.position.x = oldPos.x;
                        playerObj.position.z = oldPos.z;
                    }
                }

                // --- D. 垂直位移與落地判斷 ---
                playerObj.position.y += (velocity.y * delta);
                let groundInfo = checkCollision(playerObj.position);

                // 落地邏輯：當高度低於「地面高度 + 當前身高」
                if (playerObj.position.y <= groundInfo.floorY + currentHeight) {
                    velocity.y = 0; // 停止垂直移動
                    playerObj.position.y = groundInfo.floorY + currentHeight; // 固定在地面上
                    canJump = true; // 恢復跳躍能力
                    
                    // 當在地面移動時，產生粒子
                    if (Math.abs(velocity.x) > 0.5 || Math.abs(velocity.z) > 0.5) {
                        createParticle(playerObj.position, groundInfo.floorY);
                    }
                } else {
                    canJump = false; // 在空中不能跳
                }

                // --- E. 粒子生命週期更新 ---
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.userData.life -= delta; // 扣除生命
                    p.material.opacity = p.userData.life / 2; // 隨著壽命變透明
                    if (p.userData.life <= 0) {
                        scene.remove(p); // 從 3D 場景移除
                        particles.splice(i, 1); // 從陣列移除
                    }
                }

                prevTime = time;
            }
            renderer.render(scene, camera); // 渲染最終畫面
        }
        animate();

        // --- 10. 視窗縮放處理 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>