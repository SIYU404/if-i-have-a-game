<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>3D 第一人稱：最終完整版 (粒子+鏡像)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        #instructions {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: black; background: rgba(255, 255, 255, 0.85); padding: 20px;
            text-align: center; cursor: pointer; z-index: 100; border-radius: 10px;
            border: 2px solid #333; box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 10px; height: 10px;
            border: 2px solid black; border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; z-index: 50;
        }
    </style>
</head>
<body>

    <div id="instructions">
        <h1>點擊開始</h1>
        <p>WASD 移動 | Shift 蹲下 | 空白鍵 跳躍</p>
    </div>
    <div id="crosshair"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 1. 場景基礎設定 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe0e0e0);
        scene.fog = new THREE.Fog(0xe0e0e0, 20, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; 
        document.body.appendChild(renderer.domElement);

        const controls = new PointerLockControls(camera, document.body);
        const instructions = document.getElementById('instructions');
        instructions.addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => instructions.style.display = 'none');
        controls.addEventListener('unlock', () => instructions.style.display = 'block');

        // --- 2. 物理變數 ---
        const STAND_HEIGHT = 1.6;
        const SNEAK_HEIGHT = 0.8;
        const PLAYER_RADIUS = 0.5;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        let isSneaking = false;
        let currentHeight = STAND_HEIGHT;
        const velocity = new THREE.Vector3();
        const objects = []; 
        const mirrorObjects = [];

        // --- 3. 粒子系統設定 (已修復) ---
        const particles = [];
        const particleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        // 【修改】顏色改為淺灰色 (0xcccccc)
        const particleMaterial = new THREE.MeshBasicMaterial({ color: "#A9ABAB", transparent: true });

        // --- 4. 鍵盤監聽 ---
        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) { velocity.y += 20; canJump = false; } break;
                case 'ShiftLeft': isSneaking = true; break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isSneaking = false; break;
            }
        });

        // --- 5. 環境與燈光 ---
        const light = new THREE.HemisphereLight(0xffffff, 0x888888, 1.5);
        scene.add(light);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200), 
            new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8, metalness: 0.1 })
        );
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        const grid = new THREE.GridHelper(200, 50, 0x000000, 0xdddddd);
        grid.position.y = 0.01;
        scene.add(grid);

        // --- 6. 玩家替身 (鏡中人像) ---
        const playerGeo = new THREE.CapsuleGeometry(0.3, 1.0, 8, 16); 
        const playerMat = new THREE.MeshStandardMaterial({
            color: 0x888888,
            transparent: true,
            opacity: 0.4,
            roughness: 0.7,
            metalness: 0.1
        });
        const playerMesh = new THREE.Mesh(playerGeo, playerMat);
        playerMesh.layers.set(1); // 設定在圖層 1 (主相機看不到)
        scene.add(playerMesh);

        // --- 7. 鏡面方塊生成 ---
        function createMirrorBox(x, y, z, width, height, depth) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256); 
            const cubeCamera = new THREE.CubeCamera(0.1, 500, cubeRenderTarget);
            
            // 讓鏡子能照到圖層 1 (玩家替身)
            cubeCamera.layers.enable(1);

            const mirrorMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 1,
                roughness: 0.05,
                envMap: cubeRenderTarget.texture,
                transparent: false
            });

            const box = new THREE.Mesh(geometry, mirrorMaterial);
            box.position.set(x, y, z);

            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
            box.add(line);

            scene.add(box);
            scene.add(cubeCamera);
            objects.push(box);
            mirrorObjects.push({ mesh: box, camera: cubeCamera });
        }

        const numBoxes = 15;
        const range = 25;
        const boxWidth = 4;
        const boxHeight = 3;
        const existingPositions = []; 

        for (let i = 0; i < numBoxes; i++) {
            let posX, posZ;
            let validPosition = false;
            let attempts = 0;
            while (!validPosition && attempts < 100) {
                posX = (Math.random() - 0.5) * range; 
                posZ = (Math.random() - 0.5) * range;
                if (Math.abs(posX) < 4 && Math.abs(posZ) < 4) { attempts++; continue; }
                let overlap = false;
                for (const pos of existingPositions) {
                    const dist = Math.sqrt((posX - pos.x)**2 + (posZ - pos.z)**2);
                    if (dist < 3.0) { overlap = true; break; }
                }
                if (!overlap) validPosition = true;
                attempts++;
            }
            if (validPosition) {
                existingPositions.push({ x: posX, z: posZ });
                createMirrorBox(posX, boxHeight / 2, posZ, boxWidth, boxHeight, boxWidth);
            }
        }

        // --- 8. 輔助函式 ---
        function checkCollision(targetPos) {
            let collision = false;
            let currentFloorY = 0;
            for (const obj of objects) {
                const halfWidth = obj.geometry.parameters.width / 2;
                const halfDepth = obj.geometry.parameters.depth / 2;
                const boxMinX = obj.position.x - halfWidth; const boxMaxX = obj.position.x + halfWidth;
                const boxMinZ = obj.position.z - halfDepth; const boxMaxZ = obj.position.z + halfDepth;
                const boxTop = obj.position.y + obj.geometry.parameters.height / 2;
                const isInsideX = targetPos.x + PLAYER_RADIUS > boxMinX && targetPos.x - PLAYER_RADIUS < boxMaxX;
                const isInsideZ = targetPos.z + PLAYER_RADIUS > boxMinZ && targetPos.z - PLAYER_RADIUS < boxMaxZ;
                if (isInsideX && isInsideZ) {
                    if (targetPos.y >= boxTop + 0.1) currentFloorY = Math.max(currentFloorY, boxTop);
                    else collision = true;
                }
            }
            return { collision, floorY: currentFloorY };
        }

        // 【新增】生成粒子函式
        function createParticle(pos, floorY) {
            const p = new THREE.Mesh(particleGeometry, particleMaterial.clone());
            p.position.set(pos.x, floorY + 0.05, pos.z);
            p.userData.life = 1.0; // 粒子壽命
            scene.add(p);
            particles.push(p);
        }

        // --- 9. 主動畫迴圈 ---
        let prevTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            if (controls.isLocked) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;

                // 物理計算
                velocity.x -= velocity.x * 20.0 * delta;
                velocity.z -= velocity.z * 20.0 * delta;
                velocity.y -= 9.8 * 5.0 * delta;

                const currentSpeed = isSneaking ? 80.0 : 200.0;
                const moveDir = new THREE.Vector3();
                moveDir.z = Number(moveForward) - Number(moveBackward);
                moveDir.x = Number(moveRight) - Number(moveLeft);
                moveDir.normalize();

                if (moveForward || moveBackward) velocity.z -= moveDir.z * currentSpeed * delta;
                if (moveLeft || moveRight) velocity.x -= moveDir.x * currentSpeed * delta;

                const playerObj = controls.getObject(); 
                const oldPos = playerObj.position.clone();
                
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                if (checkCollision(playerObj.position).collision) {
                    playerObj.position.x = oldPos.x;
                    playerObj.position.z = oldPos.z;
                }

                const targetH = isSneaking ? SNEAK_HEIGHT : STAND_HEIGHT;
                currentHeight = THREE.MathUtils.lerp(currentHeight, targetH, delta * 10);

                playerObj.position.y += (velocity.y * delta);
                let groundInfo = checkCollision(playerObj.position);

                if (playerObj.position.y <= groundInfo.floorY + currentHeight) {
                    velocity.y = 0;
                    playerObj.position.y = groundInfo.floorY + currentHeight;
                    canJump = true;

                    // 【恢復】當移動且在地面時，產生淺灰粒子
                    if (Math.abs(velocity.x) > 0.5 || Math.abs(velocity.z) > 0.5) {
                        createParticle(playerObj.position, groundInfo.floorY);
                    }
                } else {
                    canJump = false;
                }

                // 更新玩家替身位置
                playerMesh.position.x = playerObj.position.x;
                playerMesh.position.z = playerObj.position.z;
                const feetY = playerObj.position.y - currentHeight;
                playerMesh.position.y = feetY + 0.8;

                // 【恢復】更新粒子生命週期
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.userData.life -= delta;
                    p.material.opacity = p.userData.life; 
                    if (p.userData.life <= 0) {
                        scene.remove(p);
                        particles.splice(i, 1);
                    }
                }

                // 更新鏡面
                mirrorObjects.forEach(obj => {
                    obj.mesh.visible = false;
                    obj.camera.position.copy(obj.mesh.position);
                    obj.camera.update(renderer, scene);
                    obj.mesh.visible = true;
                });

                prevTime = time;
            }
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>